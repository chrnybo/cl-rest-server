Design ideas:

* Don't specify the url of the apis, but generate it

(def-api-entry users
               (:method :get
                :content-types :all
                :url-prefix "user"
                :authentication :token
                :documentation "Retrieve the list of users")
               ((id :integer) &optional (include-users :boolean))
       (list-all-users))

Here we have:

(def-api-entry <entry-name> (<options>) (<arguments>)
      <body>)

Api entry options:

* method: One of :get, :put, :post, :delete
* content-types: The available content types. Either :all or a list of content-type identifiers (:json, :xml, :html, etc). Default: :all.
* url-prefix: The url-prefix. Default: the name of the entry. (.i.e "users")
* authentication: :http, :oauth, :token?
* logging: boolean
* validation-schema: A validation schema.

Arguments: list of (<var-name> <argument-type>). Builtin types: :string, :integer, :boolean

MOP:

- Define new argument types

(define-api-entry-argument-type :local-time (string)
    (local-time:universal-to-timestamp (parse-integer string)))

- Define new api-entry options

(define-api-entry-option :logging (value)
    (log5:log-for :api ...))

- Custom urls:

Attach an :api-entry-url function

Example:

(def-api-entry user 
               (:method :get
                :content-types :all
                :api-entry-url (lambda (api-entry content-types)
                                    (list "user/:id" "user.json/:id" "user.xml/:id"))))

Note that we have a parse-url function that parses and matches urls.

The api url matching is based in the urls generated by this function. There's a default api-entry-url function.

* It should be possible to define api methods from the inside of the api global definition, and from the outside too.

Example:

(define-api my-api
    (users (:request-method :get
            :authentication t) ()))

(define-api-function* my-api
    (users (:request-method :get
            :authentication t) ()))

(with-api my-api
   (define-api-function
      (users (:request-method :get
              :authentication t) ())))
            

- Define types serializers:

(defmethod serialize ((time local-time:local-time))
    (local-time:timestamp-to-universal time))

* Intermediate representations

api-implementation  --> intermediate representation -------------->  xml, json, yaml, etc
                                                     content-type

For both producing (rendering json) and consuming (post methods).

Intermediate representation = structure + values = tree of values

Example:

(list :id <user-id>
      :realname <user-realname>)


Intermediate representations need to be optional?

IDEA: instead of using an intermediate representation, we can provide a generic api for serializing objects

(defun %with-element ((content-type (eql :json)) stream body)
     (json:with-object (stream)
          (funcall body)))

(defun %with-element ((content-type (eql :xml)) stream body)
     (cxml:with-element ...))

(defmacro with-element (((content-type *content-type*) (stream *api-output*)) &body body)
  `(%with-element ,content-type ,stream (lambda () ,@body)))

* Explicit syntax?:

(make-instance 'api-entry :name 'user
                          :method :get
                          :required-args '((id :integer))
                          :optional-args '((include-groups :boolean nil))
                          :content-types :all)

* Html generation:

get:

<api-entry-url>   content-type-list-box          documentation

<parameters entry widgets>

<request-entry text area>

<response text area>

post:

<api-entry-url>   content-type-list-box          documentation

<request schema editor or text area>

<reponse text area>

* Validation schemas:

  Work on intermediate representation?
  json-schema, xml dtd?

  Used for serialization?

  Optional

* Specify api-functions return types and unserialize results

  Example:

    (define-api-function (my-api-function
                            :returns integer)
	((arg :type string)))

  Or using 'Schemas' or 'Models':

    (define-api-function (get-person
                            :returns person)
	((id :type integer)))

  The function implementation returns a person:

     (implement-api-function (get-person
          ((:unserialization :enabled t
	                     :schema person)
	   (:authorization :enabled t
	                   :type :oauth
			   :scope user-info)
	   (:caching :enabled t)		   
	   (:database :enabled t)))
	   (id)
	(get-person id))

* Desired api functions 'plugins':

  - Pagination
  - Linking
  - Sorting
  - Validation
  - Serialization
  - Unserialization
  - Logging
  - Caching
  - Authorization
  - Authentication
  - Etags

* Resources options

  Resources options can be overwritten in api-function-implementations

  (defresource (users
          ((:caching :enabled t)		   
	   (:database :enabled t)))
	   ... )

* Use anvil-connect for API authentication and authorization

* API versioning
