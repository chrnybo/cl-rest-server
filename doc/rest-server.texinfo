\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename rest-server.info
@settitle rest-server - A library for providing REST APIs in Common Lisp

@set VERSION 0.1
@set DATE January 2011

@c Version and Contact Info
@set MAINTAINERSITE @uref{https://github.com/mmontone, maintainers webpage}
@set AUTHOR Mariano Montone
@set MAINTAINER Mariano Montone
@set MAINTAINEREMAIL @email{marianomontone at gmail dot com}
@set MAINTAINERCONTACT @uref{mailto:marianomontone at gmail dot com,contact the maintainer}
@c %**end of header

@ifinfo
@format
START-INFO-DIR-ENTRY
* rest-server: (rest-server.info). A library for providing REST APIs in Common Lisp.
END-INFO-DIR-ENTRY
@end format
@end ifinfo

@c Subheadings inside a table.
@macro tsubheading{text}
@ifinfo
@subsubheading \text\
@end ifinfo
@ifnotinfo
@item @b{\text\}
@end ifnotinfo
@end macro

@copying

This manual is for rest-server version @value{VERSION}.

Copyright @copyright{} 2012 Mariano Montone

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with the Front-Cover texts being ``A GNU Manual,''
and with the Back-Cover Texts as in (a) below.  A copy of the license
is included in the section entitled ``GNU Free Documentation License.''

(a) The FSF's Back-Cover Text is: ``You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom.''

This document is part of a collection distributed under the GNU Free
Documentation License.  If you want to distribute this document
separately from the collection, you can do so by adding a copy of the
license to the document, as described in section 6 of the license.
@end quotation
@end copying

@titlepage
@title rest-server
@subtitle A library for providing REST APIs
@subtitle Release @value{VERSION}
@author by Mariano Montone

@c Output the table of contents at the beginning.
@contents

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@ifnottex
@node Top
@top Contents
@end ifnottex

@menu
* Introduction::                        What is rest-server?
* Overview::                            A rest-server overview
* API definition and implementation::   API definition and implementation
* Serialization::                       Serialization
* Schemas::                             Schemas
* Error handling::                      Error handling
* Authentication::                      Authentication
* Example::                             An api example
* System reference::                    The system reference
* References::                          Related work
* Index::                               Complete index.

@detailmenu

Introduction

* Summary::                     A brief summary of what rest-server is
* Installation::                How to install rest-server
* Feedback::                    Bug reports, ideas, patches etc.
* Conventions::                 Type-setting conventions in the manual

Overview

API definition and implementation

* API definition::              API definition
* API implementation::          API implementation

Serialization

Schemas

Error handling

Authentication

Example

System References

References

Index

@end detailmenu
@end menu

@node Introduction
@chapter Introduction
@cindex introduction

rest-server is a Common Lisp library for implementing REST APIs providers

@menu
* Summary::                     A brief summary of what rest-server is
* Installation::                How to install rest-server
* Feedback::                    Bug reports, ideas, patches etc.
* Conventions::                 Type-setting conventions in the manual
@end menu

@node Summary
@section Summary
@cindex summary

rest-server is a Common Lisp library for implementing REST APIs providers

@node Installation
@section Installation
@cindex installation

@node Feedback
@section Feedback
@cindex feedback

Mail marianomontone at gmail dot com with feedback

@node Conventions
@section Conventions
@cindex conventions

Hear are some coding conventions we'd like to follow:

@itemize @bullet

@item
We @emph{do} believe in documentation. Document your dynamic variables, functions, macros and classes. Besides, provide a documentation from a wider perspective. Provide diagrams and arquitecture documentation; examples and tutorials, too.

@item
Use widely known Common Lisp coding guidelines: @url{http://web.archive.org/web/20050305123711/www.lisp.org/table/style.htm}

@end itemize

@node Overview
@chapter Overview
@cindex overview 

REST-SERVER is a Common Lisp library for implementing REST APIs servers.

Purpose of the library:

@itemize @bullet
@item Method matching
@itemize @minus
@item Based on HTTP method (GET, PUT, POST, DELETE)
@item Based on Accept request header
@item URL parsing (argument types)
@item Matching based on "extension": i.e. /users.json or /users.xml, etc
@item Method combinations?
@end itemize

@item Serialization

@itemize @minus
@item Different serialization types (JSON, XML, S-expressions)
@end itemize

@item Materialization (unserialization)

@itemize @minus
@item Types
@end itemize

@item Error handling

@itemize @minus
@item Condition serialization
@item Error codes configuration
@end itemize

@item Validation
@itemize @minus
@item Types
@item Schemas (JSON, XML schemas)
@end itemize

@item Versioning
@itemize @minus
@item Support for api versioning?
@end itemize

@item Logging

@item Cache handling

@item Extensible
@itemize @minus
@item Backends (JSON, XML, etc)
@item Types
@item Validation
@end itemize

@item Authentication
@itemize @minus
@item Different methods (token based, oauth)
@item Avoid changing the api interface spec because of this
@end itemize

@item Modes
@itemize @minus
@item Debugging mode -> outputs full error serialization/backtrace
@item Production -> 500 internal server error
@end itemize

@item Documentation
@itemize @minus
@item For the (lisp) developer
@item For the api consumer:
@item https://github.com/mashery/iodocs
@item http://swagger.wordnik.com/
@end itemize

@item Resources
@itemize @minus
@item Good source of ideas:
@item http://django-rest-framework.org/
@item http://www.restlet.org/
@end itemize

@end itemize

@node API definition and implementation
@chapter API definition and implementation
@cindex API

This chapter is about APIs definitions and its implementation.

@menu
* API definition::              API definition
* API implementation::          API implementation
* API logging::                 API logging
@end menu

@node API definition
@section API definiton

APIs are defined using the define-api macro.

This is the syntax:

@example
(define-api <api-name> <options-plist>
    &rest
    <api-function-definition>)
@end example

where some common options are:

@itemize @bullet
@item @code{:documentation} The api docstring
@item @code{:content-types} Globally accepted content types. Valid content-types are :json, :xml, :html and :sexp
@end itemize

and

@example
<api-function-definition> := (<api-function-name> <api-function-options> <api-function-arguments>)
@end example

with required api-function options:

@itemize @bullet
@item @code{:method}. The HTTP method. One of :get, :post, :put, :delete
@item @code{:uri-prefix}. The api function uri prefix. Should start with ``/'', and encloses required arguments between @{ and @}. Example: ``/users/@{id@}''
@item @code{:documentation}. The api function documentation string.  
@end itemize

and @code{<api-function-arguments>} being a lambda-list like list with support for @code{&optional} arguments, but no keyword arguments. Besides, each argument declaration has the form @code{(<argument-name> <argument-type> <argument-docstring>)} for required arguments and @code{(<argument-name> <argument-type> <default-value> <argument-docstring>)} for optional values.

Example:

@example
(get-user (:method :get
           :content-types (list :json)
           :uri-prefix "/users/@{id@}"
           :documentation "Retrive an user")
            ((id :string "The user id")
             &optional (expand-groups :boolean nil "Expand groups if true")))
@end example

@node API implementation
@section API implementation
@cindex API

The API is supposed to be implemented in a separate package, using the @code{implement-api-function} macro. Arguments are injected with parsed values (using the argument type in the declaration). Besides, optional arguments in the declaration are assumed to be keyword arguments in the implementation. When the HTTP method is POST, or PUT, the variable name posted-content is filled with the HTTP request posted content.

For instance, when updating a user, we had the following api function declaration:

@example
(update-user (:method :put
              :content-types (list :json)
              :uri-prefix "/users/@{id@}"
              :documentation "Update a user")
          ((id :string "The user id")))
@end example

To implement that api function, we do:

@example
(implement-api-function update-user (posted-content id)
  (format nil "Update user: ~A ~A" id posted-content))
@end example

@node API logging
@section API logging
@cindex logging, log

It is possible to look at what is happening behind the scenes enabling API logging. This is useful for debugging, track how many times and how the API is being accessed, etc.

To start API logging, simply evaluate: @code{(start-api-logging)}.

The api logging output is sent to @code{*api-logging-output*}.

Only api-function-implementations with :logging option enabled are logged.

Example:

@example
(implement-api-function (get-users :logging t)
    (&key (expand-groups nil))
  (declare (ignore expand-groups))
  (with-output-to-string (s)
    (with-serializer-output s
      (with-serializer (rest-server::accept-serializer)
	(with-elements-list ("users")
	  (loop for user in (model-test:all-users)
	     do
	       (with-element ("user")
		 (set-attribute "id" (cdr (assoc :id user)))
		 (set-attribute "realname" (cdr (assoc :realname user))))))))))       
@end example

And the log output:

@example
3566032253 API: Handling GET /users by GET-USERS NIL
3566032253 Response: <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<ol class='elements'></ol> NIL
@end example

@node Serialization
@chapter Serialization
@cindex serialization

Our purpose is to handle serialization/unserialization of data in a format independent way. That means, the developer shouldn't need change the code if the client is requesting or transferring data in JSON, XML or any other supported format.

There are two ways by which the library trys to achieve that: an intermediate representation, that can be later serialized/unserialized to the desired format; and a generic streaming serialization API: generic operations for serializing data in a format independent way directly to a stream.

@menu
* General serialization interface::                     General serialization interface
* Serialization intermediate representation::           Serialization intermediate representation
* Generic streaming serialization API::                 Generic streaming serialization API
@end menu

@node General serialization interface
@section General serialization interface

Serialization output is controlled by the @code{*serializer-output*} variable, via the @code{with-serializer-output} macro.

Serialization format is selected by the @code{*serializer*} variable, via the @code{with-serializer} macro. The built-in serializers are :json for JSON, :xml for XML, :sexp for Lisp SExpressions and :html for HTML.

Example:

@example
(with-serializer-output s
   (with-serializer :json     
       (serialize *element*)))
@end example

@node Serialization intermediate representation
@section Serialization intermediate representation
@cindex intermediate representation

Intermediate representation objects are created via the @code{element}, @code{attribute} and @code{elements} macros.

Example:

@example
(defparameter *user*
  (element "user"
	   (attribute "id" 22)
	   (attribute "realname" "Mike")
	   (attribute "groups"
		      (elements "groups"
				(element "group"
					 (attribute "id" 33)
					 (attribute "title" "My group"))))))
@end example

We can then serialize that:

@example
(with-output-to-string (s)
   (with-serializer-output s
     (with-serializer :json
       (serialize *element*))))
=>

"@{\"id\":22,\"realname\":\"Mike\",\"groups\":[@{\"id\":33,\"title\":\"My group\"@}]@}"
@end example

@example
(with-output-to-string (s)
  (with-serializer-output s
     (with-serializer :xml
       (serialize *element*))))
=>

"<user><id>22</id><realname>\"Mike\"</realname><groups><group><id>33</id><title>\"My group\"</title></group></groups></user>"
@end example

@node Generic streaming serialization API
@section Generic streaming serialization API

Insted of building an intermediate representation first, and then serializing it, we can serialize our data directly to a stream via an abstract generic interface.

The macros to be used in this case are @code{with-element}, @code{with-attribute} and @code{set-attribute}, @code{with-elements-list}, @code{with-list-member}.

Example:

@example
(defparameter *streamed-element*
  (lambda ()
    (with-element ("user")
      (set-attribute "id" 22)
      (with-attribute ("realname")
	(serialize "Mike"))
      (with-attribute ("groups")
	(with-elements-list ("groups")
	  (with-list-member ("group")
	    (with-element ("group")
	      (set-attribute "id" 33)
	      (set-attribute "title" "My group"))))))))
@end example

@example

(with-output-to-string (s)
   (with-serializer-output s
     (with-serializer :json
       (funcall *streamed-element*))))

=>

"@{\"id\":22,\"realname\":\"Mike\",\"groups\":[@{\"id\":33,\"title\":\"My group\"@}]@}"
@end example

@example
(with-output-to-string (s)
	   (with-serializer-output s
	     (with-serializer :xml
	       (funcall *streamed-element*))))

=>

"<user><id>22</id><realname>\"Mike\"</realname><groups><group><group><id>33</id><title>\"My group\"</title></group></group></groups></user>"
@end example

@node Schemas
@chapter Schemas
@cindex schema

@node Error handling
@chapter Error handling
@cindex error

Error handling is controlled by the @code{%with-condition-handling} function, that is supposed to be private. The user api is the @code{with-condition-handling} macro.

The way condition handling is done is controlled by the @code{*development-mode*} variable. Its valid values are @code{:development}, @code{:production} and @code{:testing}.

When in @code{:development} program errors and conditions are not serialized or returned to the server in any way, but they are left unhandled.

In @code{:testing} program errors are serialized to the server.

And in @code{:production}, program errors are not serialized, but the request status header is modify according to the error. In general, on a program error a 500 internal server error is returned. There are special conditions, like http-not-found-error, http-internal-server-error, http-authorization-required-error, http-forbidden-error, http-service-unavailable-error, http-unsupported-media-type-error (all http-error subclasses), that should be signaled for the client to get the correct HTTP status code.

There is also special harmless-condition. Conditions from that family (subclasses) are never handled by the default error handler.

@node Authentication
@chapter Authentication

@node Example
@chapter Example

First, let's define a very simple model to work with. It is a CRUD on application users:

@example

(defpackage :model-test
  (:use :cl)
  (:export :get-user
	   :all-users
	   :add-user
	   :update-user))

(in-package :model-test)

(defvar *users* nil)

(defun make-user (id realname)
  (list (cons :id id)
	(cons :realname realname)))

(defun add-user (user)
  (push (cons (cdr (assoc :id user))
	      user)
	*users*))

(defun update-user (user)
  (let ((user-id (cdr (assoc :id user))))
    (delete-user user-id)
    (add-user user)))

(defun get-user (id)
  (cdr (assoc id *users*)))

(defun delete-user (id)
  (setf *users* (delete id *users* :test #'equalp :key #'first)))

(defun all-users ()
  (mapcar #'cdr *users*))

@end example

Now we can define an api to do CRUD operations to that model via HTTP:

@example
(defpackage :api-test
  (:use :rest-server :cl))

(in-package :api-test)

(define-api api-test
  (:documentation "This is an api test"
   :content-types (list :json :xml))
  (get-users (:method :get
              :content-types (list :json)
              :uri-prefix "/users"
              :documentation "Retrive the users list")       
             (&optional (expand-groups :boolean nil "Expand groups if true")))
  (get-user (:method :get
             :content-types (list :json)
             :uri-prefix "/users/@{id@}"
             :documentation "Retrive an user")
            ((id :string "The user id")
             &optional (expand-groups :boolean nil "Expand groups if true")))
  (create-user (:method :post
                :content-types (list :json)
                :uri-prefix "/users"
                :documentation "Create a user")
               ())
  (update-user (:method :put
                 :content-types (list :json)
                 :uri-prefix "/users/@{id@}"
                 :documentation "Update a user")
               ((id :string "The user id")))
  (delete-user (:method :delete
                 :content-types (list :json)
                 :uri-prefix "/users/@{id@}"
                 :documentation "Delete a user")
               ((id :string "The user id"))))
@end example

Now we have the API defined, but it is not actually implemented yet. To implement it, we define a new package.

@example

(defpackage :api-test-implementation
  (:use :cl :rest-server))

(in-package :api-test-implementation)

(implement-api-function get-users (&key (expand-groups nil))
  (declare (ignore expand-groups))
  (with-output-to-string (s)
    (with-serializer-output s
      (with-serializer (rest-server::accept-serializer)
	(with-elements-list ("users")
	  (loop for user in (model-test:all-users)
	     do
	       (with-element ("user")
		 (set-attribute "id" (cdr (assoc :id user)))
		 (set-attribute "realname" (cdr (assoc :realname user))))))))))       

(implement-api-function (get-user :serialization t)
    (id &key (expand-groups nil))
  (declare (ignore expand-groups))
  (let ((user (model-test:get-user id)))
    (if (not user)
	(error 'http-not-found-error)
	; else
	(element "user"
		 (attribute "id" (cdr (assoc :id user)))
		 (attribute "realname" (cdr (assoc :realname user)))))))

(defun create-user (posted-content)
  (format nil "Create user: ~A" posted-content))

(defun update-user (posted-content id)
  (format nil "Update user: ~A ~A" id posted-content))

(defun delete-user (id)
  (format nil "Delete user: ~A" id))

@end example

@node System reference
@chapter System reference

@include references.texinfo

@node References
@chapter References
@cindex reference

 [Common Lisp Directory]
 [Common Lisp Wiki]

 [Common Lisp Directory]: http://common-lisp.net
 [Common Lisp Wiki]: http://www.cliki.net

@node Index
@chapter Index
@menu
* Concept Index::          The concept index
* Class Index::            The classes index
* Function / Macro Index:: The functions and macros index
* Variable Index::         The variables index
@end menu

@node Concept Index
@section Concept Index

@printindex cp

@node Class Index
@section Class Index

@printindex tp

@node Function / Macro Index
@section Function / Macro Index
     
@printindex fn

@node Variable Index
@section Variable Index
     
@printindex vr

@bye

